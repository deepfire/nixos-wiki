This tutorial covers the major points of NixOS configuration. As an
example, we show how a user can configure NixOS to start an irc client
each time his computer starts. This page will follow the evolution of
the configuration files from a simple setup to a more advanced modular
setup.

Simple Configuration
====================

The user wants to start his irc session inside NixOS on boot. In other
distributions, you would typically add an init script inside
`/etc/init.d` or a similar directory. In NixOS, you have to keep your
dependencies clean, this implies that you have to use your configuration
to register the init script.

Lets start the irc session with irssi inside a screen daemon. The user's
`/etc/nixos/configuration.nix` will become something like:

    {pkgs, ...}:

    # pkgs is used to fetch screen & irssi.

    {
      jobs.ircSession = {
        description = "Start the irc client of username."
        startOn = "started network-interfaces";
        exec = ''/var/setuid-wrappers/sudo -u username -- ${pkgs.screen}/bin/screen -m -d -S irc ${pkgs.irssi}/bin/irssi'';
      };

      environment.systemPackages = [ pkgs.screen ];
      security.sudo.enable = true;

      # ... usual configuration ...
    }

The user evaluates this expression on his server and can then use an
alias for the command

    ssh username@my-server -t screen -d -R irc

to connect to his irc session.

Conditions
==========

The user has another computer similar to his server. He wants to re-use
his server configuration, because most of the hardware is similar. To
avoid duplicating everything, he decides to use the host name of the
computer to enable or disable services. He rewrites his
`configuration.nix` file with the `mkIf` property.

    {config, pkgs, ...}:

    {
      jobs = pkgs.lib.mkIf (config.networking.hostname == "my-server") {
        ircSession = {
          description = "Start the irc client of username."
          startOn = "started network-interfaces";
          exec = ''/var/setuid-wrappers/sudo -u username -- ${pkgs.screen}/bin/screen -m -d -S irc ${pkgs.irssi}/bin/irssi'';
        };
      };

      environment.systemPackages = pkgs.lib.mkIf (config.networking.hostname == "my-server") [ pkgs.screen ];
      security.sudo.enable = (config.networking.hostname == "my-server");

      # ... usual configuration ...
    }

 This code seems to fit his expectations, but many conditions have to be
introduced and this will become harder to maintain over time e.g. when
he wants to change his server host name.

Multiple Configurations
=======================

To avoid the complexity of the previous mixing done inside his
`configuration.nix` file, he decides to split his configuration over
multiple files where each concern is separated into its own file. He
keeps the configuration.nix file as his general configuration for both
computers and moves the rest into a file named `irc-client.nix`.

The contents of his `configuration.nix` file becomes:

    {
      require = [
        ./irc-client.nix
      ];

      # ... usual configuration ...
    }

and the contents of the `irc-client.nix` file becomes:

    {config, pkgs, ...}:

    pkgs.lib.mkIf (config.networking.hostname == "my-server") {
      jobs.ircSession = {
        description = "Start the irc client of username."
        startOn = "started network-interfaces";
        exec = ''/var/setuid-wrappers/sudo -u username -- ${pkgs.screen}/bin/screen -m -d -S irc ${pkgs.irssi}/bin/irssi'';
      };

      environment.systemPackages = [ pkgs.screen ];
      security.sudo.enable = true;
    }

This way, the complexity of changing the condition is reduced. In
addition, he can discover consistency issues within the `irc-client.nix`
file which makes this file maintainable.

Sharing Configuration
=====================

The user has discussed his configuration on irc and some other person
wants to benefits form his modification. Thus he has to remove all parts
which are dependent on his system and make it more general. So he
decides to replace the condition and the username by options.

He modifies irc-client.nix to look like this:

    {config, pkgs, ...}:

    let
      cfg = config.services.ircClient;
    in

    with pkgs.lib;

    {
      options = {
        services.ircClient = {
          enable = mkOption {
            default = false;
            type = with types; bool;
            description = ''
              Start an irc client for a user.
            '';
          };

          user = mkOption {
            default = "username";
            type = with types; uniq string;
            description = ''
              Name of the user.
            '';
          };
        };
      };

      config = mkIf cfg.enable {
        jobs.ircSession = {
          description = "Start the irc client of ${cfg.user}."
          startOn = "started network-interfaces";
          exec = ''/var/setuid-wrappers/sudo -u ${cfg.user} -- ${pkgs.screen}/bin/screen -m -d -S irc ${pkgs.irssi}/bin/irssi'';
        };

        environment.systemPackages = [ pkgs.screen ];
        security.sudo.enable = true;
      };
    }

This module is now independent of the system and the user can modify his
`configuration.nix` to get his previous configuration.

    {config, ...}:

    {
      require = [
        ./irc-client.nix
      ];

      services.ircClient.enable = config.networking.hostname == "my-server";
      services.ircClient.user = "username";

      # ... usual configuration ...
    }

Multiple Daemons
================

The user now hosts multiple person on his server, and they want to have
the same irc client running in background. One easy possibility would be
to replace the user name by a list of user names, but this would not add
more value in this tutorial. Another solution is to extend jobs with the
irc client options. This will extend the options available inside
`jobs.<name>`.

    {config, pkgs, ...}:

    let
      anyIrcClient = with pkgs.lib;
        fold (j: v: v || j.ircClient.enable) (attrValues config.jobs);
    in

    with pkgs.lib;

    {
      options = {
        jobs.options = {config, ...}: let
          cfg = config.ircClient;
        in {
          options = {
            ircClient.enable = mkOption {
              default = false;
              type = with types; bool;
              description = ''
                Start an irc client for a user.
              '';
            };

            ircClient.user = mkOption {
              default = "username";
              type = with types; uniq string;
              description = ''
                Name of the user.
              '';
            };
          };

          config = mkIf cfg.enable {
            description = "Start the irc client of ${cfg.user}."
            startOn = "started network-interfaces";
            exec = ''/var/setuid-wrappers/sudo -u ${cfg.user} -- ${pkgs.screen}/bin/screen -m -d -S irc ${pkgs.irssi}/bin/irssi'';
          };
        };
      };

      config = mkIf anyIrcClient {
        environment.systemPackages = [ pkgs.screen ];
        security.sudo.enable = true;
      };
    }

Test your modules in a Virtual Machine with build-vm
====================================================

To test your new service in a VM create a file e.g. my-new-service.nix:

    {config, pkgs, ...}:
    {
      # You need to configure a root filesytem
      fileSystems."/".label = "vmdisk";

      # The test vm name is based on the hostname, so it's nice to set one
      networking.hostName = "vmhost"; 

      # Add a test user who can sudo to the root account for debugging
      users.extraUsers.vm = {
        password = "vm";
        shell = "${pkgs.bash}/bin/bash";
        group = "wheel";
      };
      security.sudo = {
        enable = true;
        wheelNeedsPassword = false;
      };

      # Enable your new service!
      services =  {
        myNewService = {
          enable = true;
        };
      };
    }

Then you can build a vm for testing:

    $ NIXOS_CONFIG=`pwd`/vmtest.nix nixos-rebuild  -I nixos=/path/to/nixos/ build-vm

... and run it:

    $ ./result/bin/run-vmhost-vm

... work in progress ...

