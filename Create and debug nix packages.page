This article describes how to work with the nix related repositories to
add new packages, edit and debug existing packages and also how to
create and edit configuration options and services for NixOS.

The nix repositories are hosted here: <https://github.com/nixos>

Basics
------

The code for nix packages is managed in the nixpkgs repository. NixOS
services, and other system configuration options are managed in the
nixos repository.

The steps to take for your first change should look something like this:

1.  Fork the repo (e.g. click the fork button on
    <https://github.com/nixos/nixpkgs>).
2.  Clone your fork `git clone git@github.com:nixnoob/nix-ray.git`
3.  Hack hack hack
4.  Push your changes to your fork
5.  Open a pull request
6.  Profit!

This is pretty much the standard way to use github, so if you have
trouble using git or github any general guide on these should get you
going, or just ask on the NixOS IRC channel. The rest of this guide
deals with the "Hack hack hack" step :)

How to install from the local repository
----------------------------------------

For the sake of this article, let's set an environment variable which
points to the directory where we've cloned our repos.

     $ export NIXREPOS=/home/nixnoob/nixrepos

make some changes ...

**example: list all available software** from the local repository
\$NIXREPOS/nixpkgs

     $ nix-env -f $NIXREPOS/nixpkgs -qaP '*'

**example: install software from local repository**

     $ nix-env -f $NIXREPOS/nixpkgs -i python-urlgrabber

**example: update the system** based on your local **\$NIXREPOS/nixos**
and **\$NIXREPOS/nixpkgs**

     $ nixos-rebuild -I nixos=$NIXREPOS/nixos -I nixpkgs=$NIXREPOS/nixpkgs switch

**example: build an expression and put the output in to
\`pwd\`/results**

     $ nix-build $NIXREPOS/nixpkgs -A irssi

**example: get an environment which is used to build irssi (also see
nix-shell)**

     $ nix-build $NIXREPOS/nixpkgs --run-env -A irssi

**example: get an persistent environment which is used to build irssi**

     $ nix-build $NIXREPOS/nixpkgs --run-env -A irssi --add-root

**NOTE:** it would be awesome if there was a bash/zsh extension which
would export NIX\_PATH=$NIXREPOS, when entering the directory $NIXREPOS/
in a shell.

git
---

### git rebase

     git pull upstream master

now after some modifications ...

     git add foo
     git commit
     git fetch upstream master
     git pull --rebase upstream master
     git push upstream

### theory: keeping in sync with hydra builds

problem: if you use a local git checkout of nixos/nixpkgs's **upstream
master** to develop software with, you might end up in compiling a lot
when doing: **nixos-rebuild switch**. this happens for example when
there is a fundamental change which requires a lot of packages to be
rebuilt. It is even likely that you hit bugs/issues which are caused by
someone else.

Ideally **you want to change the state of your current system** which
means that **you will not work on upstream/master** but **on the state
of the channel** which is known to be pretty stable.

A channel is only updated if a hydra build job succeeded, that means
(compared to using a local upstream/master git checkout of
nixos/nixpkgs) if you type **nix-env -i firefox**

    * you might get an older binary substitute if the hydra build of the new expression hasn't finished yet
    * you might get an older binary substitute if the hydra build of a newer version failed

#### how does this work

then run:

      nixos-version
      0.2pre-769b74c-f430032

note: the first number (769b74) is nixos revision, the second number is
the nixpkgs (f430032) revision which is

note: requires version nix-1.6.x

then run:

      cd $NIXREPOS/nixpkgs
      git pull
      git checkout -b nixpkgschannel f430032
      nix-shell $NIXREPOS/nixpkgs  -A bc
      mkdir -p /tmp/foo/out
      cd /tmp/foo
      export out=/tmp/foo/out

also modify the configureFlags prefix:

      export configureFlags="--prefix=$out --with-readline"

now we have find out which phases we need to run:

       typeset -f genericBuild | grep 'phases='
       phases="$prePhases unpackPhase patchPhase $preConfigurePhases configurePhase $preBuildPhases buildPhase checkPhase $preInstallPhases installPhase fixupPhase installCheckPhase $preDistPhases distPhase $postPhases";

so when developing you need to run these phases in a row:

      unpackPhase
      patchPhase
      configurePhase
      buildPhase
      checkPhase
      installPhase
      fixPhase
      installCheckPhase
      installPhase
      distPhase

note: you do not need to run \$preConfigurePhase explicitly as it is
run, when running configurePhase already.

list all functions which are declared in **set**:

      typeset -F
      declare -f addCVars
      declare -f addToCrossEnv
      declare -f addToNativeEnv
      declare -f addToSearchPath
      declare -f addToSearchPathWithCustomDelimiter
      declare -f buildPhase
      declare -f checkPhase
      declare -f closeNest
      declare -f command_not_found_handle
      declare -f configurePhase
      declare -f distPhase
      declare -f dumpVars
      declare -f ensureDir
      declare -f exitHandler
      declare -f findInputs
      declare -f fixLibtool
      declare -f fixupPhase
      declare -f genericBuild
      declare -f header
      declare -f installBin
      declare -f installCheckPhase
      declare -f installPhase
      declare -f patchELF
      declare -f patchPhase
      declare -f patchShebangs
      declare -f runHook
      declare -f showPhaseHeader
      declare -f startNest
      declare -f stopNest
      declare -f stripDirs
      declare -f stripHash
      declare -f substitute
      declare -f substituteAll
      declare -f substituteAllInPlace
      declare -f substituteInPlace
      declare -f unpackFile
      declare -f unpackPhase

list a particular function type:

      typeset -f unpackPhase
      
      unpackPhase () 
      { 
          runHook preUnpack;
          if [ -z "$srcs" ]; then
              if [ -z "$src" ]; then
                  echo 'variable $src or $srcs should point to the source';
                  exit 1;
              fi;
              srcs="$src";
          fi;
          local dirsBefore="";
          for i in *;
          do
              if [ -d "$i" ]; then
                  dirsBefore="$dirsBefore $i ";
              fi;
          done;
          for i in $srcs;
          do
              unpackFile $i;
          done;
          if [ -n "$setSourceRoot" ]; then
              runHook setSourceRoot;
          else
              if [ -z "$sourceRoot" ]; then
                  sourceRoot=;
                  for i in *;
                  do
                      if [ -d "$i" ]; then
                          case $dirsBefore in 
                              *\ $i\ *)
      
                              ;;
                              *)
                                  if [ -n "$sourceRoot" ]; then
                                      echo "unpacker produced multiple directories";
                                      exit 1;
                                  fi;
                                  sourceRoot="$i"
                              ;;
                          esac;
                      fi;
                  done;
              fi;
          fi;
          if [ -z "$sourceRoot" ]; then
              echo "unpacker appears to have produced no directories";
              exit 1;
          fi;
          echo "source root is $sourceRoot";
          if [ "$dontMakeSourcesWritable" != 1 ]; then
              chmod -R u+w "$sourceRoot";
          fi;
          runHook postUnpack
      }

nix channels
------------

nix channels can be used in parallel with your new local repositories,
see its
[nix-channel-documentation](//Install/remove software#nix-channels)

